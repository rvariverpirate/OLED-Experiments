
out.elf:     file format elf32-tradlittlemips


Disassembly of section .config_BFC02FF0:

bfc02ff0 <__config_BFC02FF0>:
bfc02ff0:	ff ff fe fa                                         ....

Disassembly of section .config_BFC02FF4:

bfc02ff4 <__config_BFC02FF4>:
bfc02ff4:	d9 79 f8 ff                                         .y..

Disassembly of section .config_BFC02FF8:

bfc02ff8 <__config_BFC02FF8>:
bfc02ff8:	db ce 6c ff                                         ..l.

Disassembly of section .config_BFC02FFC:

bfc02ffc <__config_BFC02FFC>:
bfc02ffc:	ff ff ff 7e                                         ...~

Disassembly of section .reset:

bd001970 <_reset>:
bd001970:	0f40065e 	jal	bd001978 <_startup>
bd001974:	00000000 	nop

bd001978 <_startup>:
bd001978:	401a6000 	mfc0	k0,c0_status
bd00197c:	7f5a04c0 	ext	k0,k0,0x13,0x1
bd001980:	13400005 	beqz	k0,bd001998 <_no_nmi>
bd001984:	00000000 	nop
bd001988:	3c1a9d00 	lui	k0,0x9d00
bd00198c:	275a2e18 	addiu	k0,k0,11800
bd001990:	03400008 	jr	k0
bd001994:	00000000 	nop

bd001998 <_no_nmi>:
bd001998:	3c1da002 	lui	sp,0xa002
bd00199c:	27bdfff0 	addiu	sp,sp,-16
bd0019a0:	3c1ca000 	lui	gp,0xa000
bd0019a4:	279c7ff0 	addiu	gp,gp,32752
bd0019a8:	40096002 	mfc0	t1,c0_srsctl
bd0019ac:	01205820 	add	t3,t1,zero
bd0019b0:	7d2a1e80 	ext	t2,t1,0x1a,0x4
bd0019b4:	7d494984 	ins	t1,t2,0x6,0x4
bd0019b8:	40896002 	mtc0	t1,c0_srsctl
bd0019bc:	000000c0 	ehb
bd0019c0:	41dce000 	wrpgpr	gp,gp
bd0019c4:	408b6002 	mtc0	t3,c0_srsctl
bd0019c8:	000000c0 	ehb
bd0019cc:	3c089d00 	lui	t0,0x9d00
bd0019d0:	25082e30 	addiu	t0,t0,11824
bd0019d4:	0100f809 	jalr	t0
bd0019d8:	00000000 	nop

bd0019dc <_start_bss_init>:
bd0019dc:	3c08a000 	lui	t0,0xa000
bd0019e0:	25080000 	addiu	t0,t0,0
bd0019e4:	3c09a000 	lui	t1,0xa000
bd0019e8:	25290020 	addiu	t1,t1,32
bd0019ec:	10000006 	b	bd001a08 <_bss_check>
bd0019f0:	00000000 	nop

bd0019f4 <_bss_init>:
bd0019f4:	ad000000 	sw	zero,0(t0)
bd0019f8:	ad000004 	sw	zero,4(t0)
bd0019fc:	ad000008 	sw	zero,8(t0)
bd001a00:	ad00000c 	sw	zero,12(t0)
bd001a04:	25080010 	addiu	t0,t0,16

bd001a08 <_bss_check>:
bd001a08:	0109082b 	sltu	at,t0,t1
bd001a0c:	1420fff9 	bnez	at,bd0019f4 <_bss_init>
bd001a10:	00000000 	nop

bd001a14 <_dinit_init>:
bd001a14:	3c089d00 	lui	t0,0x9d00
bd001a18:	25082df8 	addiu	t0,t0,11768
bd001a1c:	8d090000 	lw	t1,0(t0)
bd001a20:	11200018 	beqz	t1,bd001a84 <_dinit_end+0x18>
bd001a24:	25080004 	addiu	t0,t0,4
bd001a28:	8d0a0000 	lw	t2,0(t0)
bd001a2c:	25080004 	addiu	t0,t0,4
bd001a30:	8d0b0000 	lw	t3,0(t0)
bd001a34:	11600009 	beqz	t3,bd001a5c <_dinit_clear>
bd001a38:	25080004 	addiu	t0,t0,4

bd001a3c <_dinit_copy>:
bd001a3c:	910c0000 	lbu	t4,0(t0)
bd001a40:	254affff 	addiu	t2,t2,-1
bd001a44:	25080001 	addiu	t0,t0,1
bd001a48:	a12c0000 	sb	t4,0(t1)
bd001a4c:	1540fffb 	bnez	t2,bd001a3c <_dinit_copy>
bd001a50:	25290001 	addiu	t1,t1,1
bd001a54:	10000005 	b	bd001a6c <_dinit_end>
bd001a58:	00000000 	nop

bd001a5c <_dinit_clear>:
bd001a5c:	a1200000 	sb	zero,0(t1)
bd001a60:	254affff 	addiu	t2,t2,-1
bd001a64:	1540fffd 	bnez	t2,bd001a5c <_dinit_clear>
bd001a68:	25290001 	addiu	t1,t1,1

bd001a6c <_dinit_end>:
bd001a6c:	25080003 	addiu	t0,t0,3
bd001a70:	240afffc 	li	t2,-4
bd001a74:	01484024 	and	t0,t2,t0
bd001a78:	8d090000 	lw	t1,0(t0)
bd001a7c:	1520ffe7 	bnez	t1,bd001a1c <_dinit_init+0x8>
bd001a80:	00000000 	nop
bd001a84:	3c090000 	lui	t1,0x0
bd001a88:	25290000 	addiu	t1,t1,0
bd001a8c:	11200010 	beqz	t1,bd001ad0 <_ramfunc_done>
bd001a90:	00000000 	nop
bd001a94:	3c090002 	lui	t1,0x2
bd001a98:	25290000 	addiu	t1,t1,0
bd001a9c:	3c0abf88 	lui	t2,0xbf88
bd001aa0:	254a2010 	addiu	t2,t2,8208
bd001aa4:	ad490000 	sw	t1,0(t2)
bd001aa8:	3c090002 	lui	t1,0x2
bd001aac:	25290000 	addiu	t1,t1,0
bd001ab0:	3c0abf88 	lui	t2,0xbf88
bd001ab4:	254a2020 	addiu	t2,t2,8224
bd001ab8:	ad490000 	sw	t1,0(t2)
bd001abc:	3c090002 	lui	t1,0x2
bd001ac0:	25290000 	addiu	t1,t1,0
bd001ac4:	3c0abf88 	lui	t2,0xbf88
bd001ac8:	254a2030 	addiu	t2,t2,8240
bd001acc:	ad490000 	sw	t1,0(t2)

bd001ad0 <_ramfunc_done>:
bd001ad0:	40804800 	mtc0	zero,c0_count
bd001ad4:	240affff 	li	t2,-1
bd001ad8:	408a5800 	mtc0	t2,c0_compare
bd001adc:	3c080040 	lui	t0,0x40
bd001ae0:	400a6000 	mfc0	t2,c0_status
bd001ae4:	010a5025 	or	t2,t0,t2
bd001ae8:	408a6000 	mtc0	t2,c0_status
bd001aec:	3c099d00 	lui	t1,0x9d00
bd001af0:	25290000 	addiu	t1,t1,0
bd001af4:	000000c0 	ehb
bd001af8:	40897801 	mtc0	t1,c0_ebase
bd001afc:	3c090000 	lui	t1,0x0
bd001b00:	25290001 	addiu	t1,t1,1
bd001b04:	240a0000 	li	t2,0
bd001b08:	7d2a4944 	ins	t2,t1,0x5,0x5
bd001b0c:	408a6001 	mtc0	t2,c0_intctl
bd001b10:	3c090080 	lui	t1,0x80
bd001b14:	40896800 	mtc0	t1,c0_cause
bd001b18:	40088000 	mfc0	t0,c0_config
bd001b1c:	7d090580 	ext	t1,t0,0x16,0x1
bd001b20:	00094c40 	sll	t1,t1,0x11
bd001b24:	40086000 	mfc0	t0,c0_status
bd001b28:	3c010058 	lui	at,0x58
bd001b2c:	01014024 	and	t0,t0,at
bd001b30:	01284025 	or	t0,t1,t0
bd001b34:	40886000 	mtc0	t0,c0_status
bd001b38:	000000c0 	ehb
bd001b3c:	3c089d00 	lui	t0,0x9d00
bd001b40:	25082e38 	addiu	t0,t0,11832
bd001b44:	0100f809 	jalr	t0
bd001b48:	00000000 	nop
bd001b4c:	40086000 	mfc0	t0,c0_status
bd001b50:	3c01ffbf 	lui	at,0xffbf
bd001b54:	3421ffff 	ori	at,at,0xffff
bd001b58:	01014024 	and	t0,t0,at
bd001b5c:	40886000 	mtc0	t0,c0_status
bd001b60:	30840000 	andi	a0,a0,0x0
bd001b64:	30a50000 	andi	a1,a1,0x0
bd001b68:	3c089d00 	lui	t0,0x9d00
bd001b6c:	25082c88 	addiu	t0,t0,11400
bd001b70:	01000008 	jr	t0
bd001b74:	00000000 	nop

Disassembly of section .bev_excpt:

bd001cf0 <_bev_exception>:
bd001cf0:	3c1a9d00 	lui	k0,0x9d00
bd001cf4:	275a2cdc 	addiu	k0,k0,11484
bd001cf8:	03400008 	jr	k0
bd001cfc:	00000000 	nop

Disassembly of section .app_excpt:

9d000180 <_gen_exception>:
9d000180:	3c1a9d00 	lui	k0,0x9d00
9d000184:	275a2b04 	addiu	k0,k0,11012
9d000188:	03400008 	jr	k0
9d00018c:	00000000 	nop

Disassembly of section .vector_0:

9d000200 <__vector_dispatch_0>:
9d000200:	0b400b5b 	j	9d002d6c <.LFE0>
9d000204:	00000000 	nop

Disassembly of section .vector_1:

9d000220 <__vector_dispatch_1>:
9d000220:	0b400b5b 	j	9d002d6c <.LFE0>
9d000224:	00000000 	nop

Disassembly of section .vector_2:

9d000240 <__vector_dispatch_2>:
9d000240:	0b400b5b 	j	9d002d6c <.LFE0>
9d000244:	00000000 	nop

Disassembly of section .vector_3:

9d000260 <__vector_dispatch_3>:
9d000260:	0b400b5b 	j	9d002d6c <.LFE0>
9d000264:	00000000 	nop

Disassembly of section .vector_4:

9d000280 <__vector_dispatch_4>:
9d000280:	0b400b5b 	j	9d002d6c <.LFE0>
9d000284:	00000000 	nop

Disassembly of section .vector_5:

9d0002a0 <__vector_dispatch_5>:
9d0002a0:	0b400b5b 	j	9d002d6c <.LFE0>
9d0002a4:	00000000 	nop

Disassembly of section .vector_6:

9d0002c0 <__vector_dispatch_6>:
9d0002c0:	0b400b5b 	j	9d002d6c <.LFE0>
9d0002c4:	00000000 	nop

Disassembly of section .vector_7:

9d0002e0 <__vector_dispatch_7>:
9d0002e0:	0b400b5b 	j	9d002d6c <.LFE0>
9d0002e4:	00000000 	nop

Disassembly of section .vector_8:

9d000300 <__vector_dispatch_8>:
9d000300:	0b400b5b 	j	9d002d6c <.LFE0>
9d000304:	00000000 	nop

Disassembly of section .vector_9:

9d000320 <__vector_dispatch_9>:
9d000320:	0b400b5b 	j	9d002d6c <.LFE0>
9d000324:	00000000 	nop

Disassembly of section .vector_10:

9d000340 <__vector_dispatch_10>:
9d000340:	0b400b5b 	j	9d002d6c <.LFE0>
9d000344:	00000000 	nop

Disassembly of section .vector_11:

9d000360 <__vector_dispatch_11>:
9d000360:	0b400b5b 	j	9d002d6c <.LFE0>
9d000364:	00000000 	nop

Disassembly of section .vector_12:

9d000380 <__vector_dispatch_12>:
9d000380:	0b400b5b 	j	9d002d6c <.LFE0>
9d000384:	00000000 	nop

Disassembly of section .vector_13:

9d0003a0 <__vector_dispatch_13>:
9d0003a0:	0b400b5b 	j	9d002d6c <.LFE0>
9d0003a4:	00000000 	nop

Disassembly of section .vector_14:

9d0003c0 <__vector_dispatch_14>:
9d0003c0:	0b400b5b 	j	9d002d6c <.LFE0>
9d0003c4:	00000000 	nop

Disassembly of section .vector_15:

9d0003e0 <__vector_dispatch_15>:
9d0003e0:	0b400b5b 	j	9d002d6c <.LFE0>
9d0003e4:	00000000 	nop

Disassembly of section .vector_16:

9d000400 <__vector_dispatch_16>:
9d000400:	0b400b5b 	j	9d002d6c <.LFE0>
9d000404:	00000000 	nop

Disassembly of section .vector_17:

9d000420 <__vector_dispatch_17>:
9d000420:	0b400b5b 	j	9d002d6c <.LFE0>
9d000424:	00000000 	nop

Disassembly of section .vector_18:

9d000440 <__vector_dispatch_18>:
9d000440:	0b400b5b 	j	9d002d6c <.LFE0>
9d000444:	00000000 	nop

Disassembly of section .vector_19:

9d000460 <__vector_dispatch_19>:
9d000460:	0b400b5b 	j	9d002d6c <.LFE0>
9d000464:	00000000 	nop

Disassembly of section .vector_20:

9d000480 <__vector_dispatch_20>:
9d000480:	0b400b5b 	j	9d002d6c <.LFE0>
9d000484:	00000000 	nop

Disassembly of section .vector_21:

9d0004a0 <__vector_dispatch_21>:
9d0004a0:	0b400b5b 	j	9d002d6c <.LFE0>
9d0004a4:	00000000 	nop

Disassembly of section .vector_22:

9d0004c0 <__vector_dispatch_22>:
9d0004c0:	0b400b5b 	j	9d002d6c <.LFE0>
9d0004c4:	00000000 	nop

Disassembly of section .vector_23:

9d0004e0 <__vector_dispatch_23>:
9d0004e0:	0b400b5b 	j	9d002d6c <.LFE0>
9d0004e4:	00000000 	nop

Disassembly of section .vector_24:

9d000500 <__vector_dispatch_24>:
9d000500:	0b400b5b 	j	9d002d6c <.LFE0>
9d000504:	00000000 	nop

Disassembly of section .vector_25:

9d000520 <__vector_dispatch_25>:
9d000520:	0b4008d8 	j	9d002360 <I2C1MasterInterrupt>
9d000524:	00000000 	nop

Disassembly of section .vector_26:

9d000540 <__vector_dispatch_26>:
9d000540:	0b400b5b 	j	9d002d6c <.LFE0>
9d000544:	00000000 	nop

Disassembly of section .vector_27:

9d000560 <__vector_dispatch_27>:
9d000560:	0b400b5b 	j	9d002d6c <.LFE0>
9d000564:	00000000 	nop

Disassembly of section .vector_28:

9d000580 <__vector_dispatch_28>:
9d000580:	0b400b5b 	j	9d002d6c <.LFE0>
9d000584:	00000000 	nop

Disassembly of section .vector_29:

9d0005a0 <__vector_dispatch_29>:
9d0005a0:	0b400b5b 	j	9d002d6c <.LFE0>
9d0005a4:	00000000 	nop

Disassembly of section .vector_30:

9d0005c0 <__vector_dispatch_30>:
9d0005c0:	0b400b5b 	j	9d002d6c <.LFE0>
9d0005c4:	00000000 	nop

Disassembly of section .vector_31:

9d0005e0 <__vector_dispatch_31>:
9d0005e0:	0b400b5b 	j	9d002d6c <.LFE0>
9d0005e4:	00000000 	nop

Disassembly of section .vector_32:

9d000600 <__vector_dispatch_32>:
9d000600:	0b400b5b 	j	9d002d6c <.LFE0>
9d000604:	00000000 	nop

Disassembly of section .vector_33:

9d000620 <__vector_dispatch_33>:
9d000620:	0b400b5b 	j	9d002d6c <.LFE0>
9d000624:	00000000 	nop

Disassembly of section .vector_34:

9d000640 <__vector_dispatch_34>:
9d000640:	0b400b5b 	j	9d002d6c <.LFE0>
9d000644:	00000000 	nop

Disassembly of section .vector_35:

9d000660 <__vector_dispatch_35>:
9d000660:	0b400b5b 	j	9d002d6c <.LFE0>
9d000664:	00000000 	nop

Disassembly of section .vector_36:

9d000680 <__vector_dispatch_36>:
9d000680:	0b400b5b 	j	9d002d6c <.LFE0>
9d000684:	00000000 	nop

Disassembly of section .vector_37:

9d0006a0 <__vector_dispatch_37>:
9d0006a0:	0b400b5b 	j	9d002d6c <.LFE0>
9d0006a4:	00000000 	nop

Disassembly of section .vector_38:

9d0006c0 <__vector_dispatch_38>:
9d0006c0:	0b400b5b 	j	9d002d6c <.LFE0>
9d0006c4:	00000000 	nop

Disassembly of section .vector_39:

9d0006e0 <__vector_dispatch_39>:
9d0006e0:	0b400b5b 	j	9d002d6c <.LFE0>
9d0006e4:	00000000 	nop

Disassembly of section .vector_40:

9d000700 <__vector_dispatch_40>:
9d000700:	0b400b5b 	j	9d002d6c <.LFE0>
9d000704:	00000000 	nop

Disassembly of section .vector_41:

9d000720 <__vector_dispatch_41>:
9d000720:	0b400b5b 	j	9d002d6c <.LFE0>
9d000724:	00000000 	nop

Disassembly of section .vector_42:

9d000740 <__vector_dispatch_42>:
9d000740:	0b400b5b 	j	9d002d6c <.LFE0>
9d000744:	00000000 	nop

Disassembly of section .vector_43:

9d000760 <__vector_dispatch_43>:
9d000760:	0b400b5b 	j	9d002d6c <.LFE0>
9d000764:	00000000 	nop

Disassembly of section .vector_44:

9d000780 <__vector_dispatch_44>:
9d000780:	0b400b5b 	j	9d002d6c <.LFE0>
9d000784:	00000000 	nop

Disassembly of section .vector_45:

9d0007a0 <__vector_dispatch_45>:
9d0007a0:	0b400b5b 	j	9d002d6c <.LFE0>
9d0007a4:	00000000 	nop

Disassembly of section .vector_46:

9d0007c0 <__vector_dispatch_46>:
9d0007c0:	0b400b5b 	j	9d002d6c <.LFE0>
9d0007c4:	00000000 	nop

Disassembly of section .vector_47:

9d0007e0 <__vector_dispatch_47>:
9d0007e0:	0b400b5b 	j	9d002d6c <.LFE0>
9d0007e4:	00000000 	nop

Disassembly of section .vector_48:

9d000800 <__vector_dispatch_48>:
9d000800:	0b400b5b 	j	9d002d6c <.LFE0>
9d000804:	00000000 	nop

Disassembly of section .vector_49:

9d000820 <__vector_dispatch_49>:
9d000820:	0b400b5b 	j	9d002d6c <.LFE0>
9d000824:	00000000 	nop

Disassembly of section .vector_50:

9d000840 <__vector_dispatch_50>:
9d000840:	0b400b5b 	j	9d002d6c <.LFE0>
9d000844:	00000000 	nop

Disassembly of section .vector_51:

9d000860 <__vector_dispatch_51>:
9d000860:	0b400b5b 	j	9d002d6c <.LFE0>
9d000864:	00000000 	nop

Disassembly of section ._debug_exception:

bfc00480 <__DbgExecReturn>:
bfc00480:	409bf800 	mtc0	k1,c0_desave
bfc00484:	000000c0 	ehb
bfc00488:	3c1b9d00 	lui	k1,0x9d00
bfc0048c:	277b2db4 	addiu	k1,k1,11700
bfc00490:	13600002 	beqz	k1,bfc0049c <__DbgExecReturn+0x1c>
bfc00494:	00000000 	nop
bfc00498:	409bc000 	mtc0	k1,c0_depc
bfc0049c:	401bf800 	mfc0	k1,c0_desave
bfc004a0:	000000c0 	ehb
bfc004a4:	4200001f 	deret
bfc004a8:	00000000 	nop

Disassembly of section .text:

9d001e00 <main>:
#include "NU32.h"         // constants, funcs for startup and UART
#include "i2c_display.h"
// Tests the OLED driver by drawing pixels

int main() {
9d001e00:	27bdfbc8 	addiu	sp,sp,-1080
9d001e04:	afbf0434 	sw	ra,1076(sp)
9d001e08:	afbe0430 	sw	s8,1072(sp)
9d001e0c:	afb7042c 	sw	s7,1068(sp)
9d001e10:	afb60428 	sw	s6,1064(sp)
9d001e14:	afb50424 	sw	s5,1060(sp)
9d001e18:	afb40420 	sw	s4,1056(sp)
9d001e1c:	afb3041c 	sw	s3,1052(sp)
9d001e20:	afb20418 	sw	s2,1048(sp)
9d001e24:	afb10414 	sw	s1,1044(sp)
9d001e28:	afb00410 	sw	s0,1040(sp)
  // width: 128 height: 64
const unsigned char imageHex[] = {
9d001e2c:	27a40010 	addiu	a0,sp,16
9d001e30:	00002821 	move	a1,zero
9d001e34:	0f400af8 	jal	9d002be0 <memset>
9d001e38:	24060400 	li	a2,1024
9d001e3c:	240c005a 	li	t4,90
9d001e40:	a3ac0107 	sb	t4,263(sp)
9d001e44:	2418ffda 	li	t8,-38
9d001e48:	a3b80108 	sb	t8,264(sp)
9d001e4c:	240d001f 	li	t5,31
9d001e50:	a3ad0116 	sb	t5,278(sp)
9d001e54:	2402ffff 	li	v0,-1
9d001e58:	a3a20117 	sb	v0,279(sp)
9d001e5c:	a3a20118 	sb	v0,280(sp)
9d001e60:	2405fff0 	li	a1,-16
9d001e64:	a3a50119 	sb	a1,281(sp)
9d001e68:	2404007f 	li	a0,127
9d001e6c:	a3a40126 	sb	a0,294(sp)
9d001e70:	a3a20127 	sb	v0,295(sp)
9d001e74:	a3a20128 	sb	v0,296(sp)
9d001e78:	2407fffc 	li	a3,-4
9d001e7c:	a3a70129 	sb	a3,297(sp)
9d001e80:	a3a70136 	sb	a3,310(sp)
9d001e84:	a3a20137 	sb	v0,311(sp)
9d001e88:	a3a20138 	sb	v0,312(sp)
9d001e8c:	2403fffe 	li	v1,-2
9d001e90:	a3a30139 	sb	v1,313(sp)
9d001e94:	a3a50146 	sb	a1,326(sp)
9d001e98:	2405003f 	li	a1,63
9d001e9c:	a3a50147 	sb	a1,327(sp)
9d001ea0:	a3a20148 	sb	v0,328(sp)
9d001ea4:	a3a20149 	sb	v0,329(sp)
9d001ea8:	240bfffd 	li	t3,-3
9d001eac:	a3ab0156 	sb	t3,342(sp)
9d001eb0:	a3a40157 	sb	a0,343(sp)
9d001eb4:	a3a20158 	sb	v0,344(sp)
9d001eb8:	a3a20159 	sb	v0,345(sp)
9d001ebc:	a3a20166 	sb	v0,358(sp)
9d001ec0:	a3a20167 	sb	v0,359(sp)
9d001ec4:	a3a20168 	sb	v0,360(sp)
9d001ec8:	a3a20169 	sb	v0,361(sp)
9d001ecc:	a3a20176 	sb	v0,374(sp)
9d001ed0:	a3a20177 	sb	v0,375(sp)
9d001ed4:	a3a20178 	sb	v0,376(sp)
9d001ed8:	a3a20179 	sb	v0,377(sp)
9d001edc:	24060004 	li	a2,4
9d001ee0:	a3a60185 	sb	a2,389(sp)
9d001ee4:	24060012 	li	a2,18
9d001ee8:	a3a60186 	sb	a2,390(sp)
9d001eec:	2414ff95 	li	s4,-107
9d001ef0:	a3b40187 	sb	s4,391(sp)
9d001ef4:	a3a20188 	sb	v0,392(sp)
9d001ef8:	a3a20189 	sb	v0,393(sp)
9d001efc:	240a000f 	li	t2,15
9d001f00:	a3aa0194 	sb	t2,404(sp)
9d001f04:	a3a20195 	sb	v0,405(sp)
9d001f08:	a3a20196 	sb	v0,406(sp)
9d001f0c:	a3a20197 	sb	v0,407(sp)
9d001f10:	a3a20198 	sb	v0,408(sp)
9d001f14:	a3a20199 	sb	v0,409(sp)
9d001f18:	2406006b 	li	a2,107
9d001f1c:	a3a6019a 	sb	a2,410(sp)
9d001f20:	2406ffc0 	li	a2,-64
9d001f24:	a3a6019b 	sb	a2,411(sp)
9d001f28:	a3ad01a4 	sb	t5,420(sp)
9d001f2c:	a3a201a5 	sb	v0,421(sp)
9d001f30:	a3a201a6 	sb	v0,422(sp)
9d001f34:	a3a201a7 	sb	v0,423(sp)
9d001f38:	a3a201a8 	sb	v0,424(sp)
9d001f3c:	a3a201a9 	sb	v0,425(sp)
9d001f40:	2406003a 	li	a2,58
9d001f44:	a3a601aa 	sb	a2,426(sp)
9d001f48:	24060078 	li	a2,120
9d001f4c:	a3a601ab 	sb	a2,427(sp)
9d001f50:	a3a501b4 	sb	a1,436(sp)
9d001f54:	a3a201b5 	sb	v0,437(sp)
9d001f58:	a3a201b6 	sb	v0,438(sp)
9d001f5c:	a3a201b7 	sb	v0,439(sp)
9d001f60:	a3a201b8 	sb	v0,440(sp)
9d001f64:	a3a201b9 	sb	v0,441(sp)
9d001f68:	2405001e 	li	a1,30
9d001f6c:	a3a501ba 	sb	a1,442(sp)
9d001f70:	2405ffe4 	li	a1,-28
9d001f74:	a3a501bb 	sb	a1,443(sp)
9d001f78:	a3a201c4 	sb	v0,452(sp)
9d001f7c:	a3a201c5 	sb	v0,453(sp)
9d001f80:	a3a201c6 	sb	v0,454(sp)
9d001f84:	a3a201c7 	sb	v0,455(sp)
9d001f88:	a3a201c8 	sb	v0,456(sp)
9d001f8c:	a3a201c9 	sb	v0,457(sp)
9d001f90:	24050037 	li	a1,55
9d001f94:	a3a501ca 	sb	a1,458(sp)
9d001f98:	2405003e 	li	a1,62
9d001f9c:	a3a501cb 	sb	a1,459(sp)
9d001fa0:	a3a201d4 	sb	v0,468(sp)
9d001fa4:	a3a201d5 	sb	v0,469(sp)
9d001fa8:	a3a201d6 	sb	v0,470(sp)
9d001fac:	a3a201d7 	sb	v0,471(sp)
9d001fb0:	a3a201d8 	sb	v0,472(sp)
9d001fb4:	a3a301d9 	sb	v1,473(sp)
9d001fb8:	24110019 	li	s1,25
9d001fbc:	a3b101da 	sb	s1,474(sp)
9d001fc0:	2405fff6 	li	a1,-10
9d001fc4:	a3a501db 	sb	a1,475(sp)
9d001fc8:	a3a201e4 	sb	v0,484(sp)
9d001fcc:	a3a201e5 	sb	v0,485(sp)
9d001fd0:	a3a201e6 	sb	v0,486(sp)
9d001fd4:	a3a201e7 	sb	v0,487(sp)
9d001fd8:	a3a201e8 	sb	v0,488(sp)
9d001fdc:	a3a301e9 	sb	v1,489(sp)
9d001fe0:	a3a401ea 	sb	a0,490(sp)
9d001fe4:	2405ffa6 	li	a1,-90
9d001fe8:	a3a501eb 	sb	a1,491(sp)
9d001fec:	24080001 	li	t0,1
9d001ff0:	a3a801f3 	sb	t0,499(sp)
9d001ff4:	a3a201f4 	sb	v0,500(sp)
9d001ff8:	a3a201f5 	sb	v0,501(sp)
9d001ffc:	a3a201f6 	sb	v0,502(sp)
9d002000:	a3a201f7 	sb	v0,503(sp)
9d002004:	a3a201f8 	sb	v0,504(sp)
9d002008:	2405fff8 	li	a1,-8
9d00200c:	a3a501f9 	sb	a1,505(sp)
9d002010:	2405ffb2 	li	a1,-78
9d002014:	a3a501fa 	sb	a1,506(sp)
9d002018:	a3a201fb 	sb	v0,507(sp)
9d00201c:	a3a20204 	sb	v0,516(sp)
9d002020:	a3a20205 	sb	v0,517(sp)
9d002024:	a3a20206 	sb	v0,518(sp)
9d002028:	2405006d 	li	a1,109
9d00202c:	a3a50207 	sb	a1,519(sp)
9d002030:	a3a20208 	sb	v0,520(sp)
9d002034:	2410ffc7 	li	s0,-57
9d002038:	a3b00209 	sb	s0,521(sp)
9d00203c:	2406ffef 	li	a2,-17
9d002040:	a3a6020a 	sb	a2,522(sp)
9d002044:	2405ff99 	li	a1,-103
9d002048:	a3a5020b 	sb	a1,523(sp)
9d00204c:	a3a80213 	sb	t0,531(sp)
9d002050:	a3a20214 	sb	v0,532(sp)
9d002054:	a3a20215 	sb	v0,533(sp)
9d002058:	2405ffe5 	li	a1,-27
9d00205c:	a3a50216 	sb	a1,534(sp)
9d002060:	24050014 	li	a1,20
9d002064:	a3a50217 	sb	a1,535(sp)
9d002068:	2405006a 	li	a1,106
9d00206c:	a3a50219 	sb	a1,537(sp)
9d002070:	a3a6021a 	sb	a2,538(sp)
9d002074:	a3a2021b 	sb	v0,539(sp)
9d002078:	240eff80 	li	t6,-128
9d00207c:	a3ae021c 	sb	t6,540(sp)
9d002080:	a3a20224 	sb	v0,548(sp)
9d002084:	a3a20225 	sb	v0,549(sp)
9d002088:	2405ff85 	li	a1,-123
9d00208c:	a3a50226 	sb	a1,550(sp)
9d002090:	2409ffd7 	li	t1,-41
9d002094:	a3a90227 	sb	t1,551(sp)
9d002098:	a3a20228 	sb	v0,552(sp)
9d00209c:	2405ffbf 	li	a1,-65
9d0020a0:	a3a50229 	sb	a1,553(sp)
9d0020a4:	240f0034 	li	t7,52
9d0020a8:	a3af022a 	sb	t7,554(sp)
9d0020ac:	240f0024 	li	t7,36
9d0020b0:	a3af022b 	sb	t7,555(sp)
9d0020b4:	a3a20234 	sb	v0,564(sp)
9d0020b8:	a3a20235 	sb	v0,565(sp)
9d0020bc:	240f001b 	li	t7,27
9d0020c0:	a3af0236 	sb	t7,566(sp)
9d0020c4:	240f007d 	li	t7,125
9d0020c8:	a3af0237 	sb	t7,567(sp)
9d0020cc:	a3a50238 	sb	a1,568(sp)
9d0020d0:	2405ffa5 	li	a1,-91
9d0020d4:	a3a50239 	sb	a1,569(sp)
9d0020d8:	a3a2023a 	sb	v0,570(sp)
9d0020dc:	a3a2023b 	sb	v0,571(sp)
9d0020e0:	a3a20244 	sb	v0,580(sp)
9d0020e4:	a3a30245 	sb	v1,581(sp)
9d0020e8:	2413007e 	li	s3,126
9d0020ec:	a3b30246 	sb	s3,582(sp)
9d0020f0:	a3a90247 	sb	t1,583(sp)
9d0020f4:	2405ffd9 	li	a1,-39
9d0020f8:	a3a50248 	sb	a1,584(sp)
9d0020fc:	2405fff7 	li	a1,-9
9d002100:	a3a50249 	sb	a1,585(sp)
9d002104:	24120059 	li	s2,89
9d002108:	a3b2024a 	sb	s2,586(sp)
9d00210c:	2405ff9a 	li	a1,-102
9d002110:	a3a5024b 	sb	a1,587(sp)
9d002114:	a3a40254 	sb	a0,596(sp)
9d002118:	a3a30255 	sb	v1,597(sp)
9d00211c:	2405ffcf 	li	a1,-49
9d002120:	a3a50256 	sb	a1,598(sp)
9d002124:	2405ff9e 	li	a1,-98
9d002128:	a3a50257 	sb	a1,599(sp)
9d00212c:	2405ffdb 	li	a1,-37
9d002130:	a3a50258 	sb	a1,600(sp)
9d002134:	2419005c 	li	t9,92
9d002138:	a3b90259 	sb	t9,601(sp)
9d00213c:	2419ffe7 	li	t9,-25
9d002140:	a3b9025a 	sb	t9,602(sp)
9d002144:	2419ffec 	li	t9,-20
9d002148:	a3b9025b 	sb	t9,603(sp)
9d00214c:	a3a40264 	sb	a0,612(sp)
9d002150:	a3a70265 	sb	a3,613(sp)
9d002154:	24040074 	li	a0,116
9d002158:	a3a40266 	sb	a0,614(sp)
9d00215c:	2404fffa 	li	a0,-6
9d002160:	a3a40267 	sb	a0,615(sp)
9d002164:	a3ac0268 	sb	t4,616(sp)
9d002168:	a3a50269 	sb	a1,617(sp)
9d00216c:	2404ffbe 	li	a0,-66
9d002170:	a3a4026a 	sb	a0,618(sp)
9d002174:	2415ffbc 	li	s5,-68
9d002178:	a3b5026b 	sb	s5,619(sp)
9d00217c:	a3ad0274 	sb	t5,628(sp)
9d002180:	a3a30275 	sb	v1,629(sp)
9d002184:	2403006f 	li	v1,111
9d002188:	a3a30276 	sb	v1,630(sp)
9d00218c:	2403ffcd 	li	v1,-51
9d002190:	a3a30277 	sb	v1,631(sp)
9d002194:	a3ab0278 	sb	t3,632(sp)
9d002198:	a3a20279 	sb	v0,633(sp)
9d00219c:	a3ac027a 	sb	t4,634(sp)
9d0021a0:	2403ffd0 	li	v1,-48
9d0021a4:	a3a3027b 	sb	v1,635(sp)
9d0021a8:	a3aa0284 	sb	t2,644(sp)
9d0021ac:	a3a70285 	sb	a3,645(sp)
9d0021b0:	2403ffb9 	li	v1,-71
9d0021b4:	a3a30286 	sb	v1,646(sp)
9d0021b8:	24070077 	li	a3,119
9d0021bc:	a3a70287 	sb	a3,647(sp)
9d0021c0:	2403002b 	li	v1,43
9d0021c4:	a3a30288 	sb	v1,648(sp)
9d0021c8:	24030025 	li	v1,37
9d0021cc:	a3a30289 	sb	v1,649(sp)
9d0021d0:	a3a5028a 	sb	a1,650(sp)
9d0021d4:	24030040 	li	v1,64
9d0021d8:	a3a3028b 	sb	v1,651(sp)
9d0021dc:	240c0008 	li	t4,8
9d0021e0:	a3ac0295 	sb	t4,661(sp)
9d0021e4:	a3a70296 	sb	a3,662(sp)
9d0021e8:	a3a60297 	sb	a2,663(sp)
9d0021ec:	a3b402a6 	sb	s4,678(sp)
9d0021f0:	24070032 	li	a3,50
9d0021f4:	a3a702a7 	sb	a3,679(sp)
9d0021f8:	a3a602a8 	sb	a2,680(sp)
9d0021fc:	2406ffee 	li	a2,-18
9d002200:	a3a602a9 	sb	a2,681(sp)
9d002204:	a3a502b6 	sb	a1,694(sp)
9d002208:	a3a202b7 	sb	v0,695(sp)
9d00220c:	a3ab02b8 	sb	t3,696(sp)
9d002210:	a3a402b9 	sb	a0,697(sp)
9d002214:	a3b302c6 	sb	s3,710(sp)
9d002218:	a3b202c7 	sb	s2,711(sp)
9d00221c:	2402ff94 	li	v0,-108
9d002220:	a3a202c8 	sb	v0,712(sp)
9d002224:	a3b102c9 	sb	s1,713(sp)
9d002228:	a3b002d6 	sb	s0,726(sp)
9d00222c:	2402ffeb 	li	v0,-21
9d002230:	a3a202d7 	sb	v0,727(sp)
9d002234:	a3b902d8 	sb	t9,728(sp)
9d002238:	2402000e 	li	v0,14
9d00223c:	a3a202d9 	sb	v0,729(sp)
9d002240:	2402007c 	li	v0,124
9d002244:	a3a202e6 	sb	v0,742(sp)
9d002248:	a3a402e7 	sb	a0,743(sp)
9d00224c:	24020038 	li	v0,56
9d002250:	a3a202e8 	sb	v0,744(sp)
9d002254:	2402002a 	li	v0,42
9d002258:	a3a202e9 	sb	v0,745(sp)
9d00225c:	a3aa02f6 	sb	t2,758(sp)
9d002260:	a3b802f7 	sb	t8,759(sp)
9d002264:	a3a902f8 	sb	t1,760(sp)
9d002268:	2402ffb0 	li	v0,-80
9d00226c:	a3a202f9 	sb	v0,761(sp)
9d002270:	a3a80306 	sb	t0,774(sp)
9d002274:	2402003b 	li	v0,59
9d002278:	a3a20307 	sb	v0,775(sp)
9d00227c:	a3af0308 	sb	t7,776(sp)
9d002280:	a3ae0309 	sb	t6,777(sp)
9d002284:	24020009 	li	v0,9
9d002288:	a3a20317 	sb	v0,791(sp)
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

};// stores the binary image
  NU32_Startup();  // cache on, interrupts on, LED/button init, UART init
9d00228c:	0f400a50 	jal	9d002940 <NU32_Startup>
9d002290:	a3a30318 	sb	v1,792(sp)
  display_init();
9d002294:	0f4009dd 	jal	9d002774 <display_init>
9d002298:	00009821 	move	s3,zero
  int row, col, i, j, offset;
  row = 0;
9d00229c:	0000b821 	move	s7,zero
9d0022a0:	27b60410 	addiu	s6,sp,1040
    }
  }*/

  while(1){
    for(i = 0; i < sizeof(imageHex); i++){
      for(j = 7; 0 <= j; j--){
9d0022a4:	2414ffff 	li	s4,-1
        }
      }
    }
    display_draw();
    for(i = 0; i < WIDTH; i++){
      for(j = 0; j < HEIGHT; j++){
9d0022a8:	24120040 	li	s2,64
          col = 0;
        }
      }
    }
    display_draw();
    for(i = 0; i < WIDTH; i++){
9d0022ac:	24150080 	li	s5,128
9d0022b0:	27b10010 	addiu	s1,sp,16
          display_pixel_set(row, col, 1);
        }
        col++;
        if(col >= WIDTH){
          row++;
          col = 0;
9d0022b4:	0b4008c3 	j	9d00230c <main+0x50c>
9d0022b8:	02e0f021 	move	s8,s7
  }*/

  while(1){
    for(i = 0; i < sizeof(imageHex); i++){
      for(j = 7; 0 <= j; j--){
        if((imageHex[i] >> j) & 0x01){
9d0022bc:	92220000 	lbu	v0,0(s1)
9d0022c0:	02021007 	srav	v0,v0,s0
9d0022c4:	30420001 	andi	v0,v0,0x1
9d0022c8:	50400006 	beqzl	v0,9d0022e4 <main+0x4e4>
9d0022cc:	26730001 	addiu	s3,s3,1
          display_pixel_set(row, col, 1);
9d0022d0:	03c02021 	move	a0,s8
9d0022d4:	02602821 	move	a1,s3
9d0022d8:	0f400a13 	jal	9d00284c <display_pixel_set>
9d0022dc:	24060001 	li	a2,1
        }
        col++;
9d0022e0:	26730001 	addiu	s3,s3,1
        if(col >= WIDTH){
9d0022e4:	2a620080 	slti	v0,s3,128
9d0022e8:	14400003 	bnez	v0,9d0022f8 <main+0x4f8>
9d0022ec:	2610ffff 	addiu	s0,s0,-1
          row++;
9d0022f0:	27de0001 	addiu	s8,s8,1
          col = 0;
9d0022f4:	00009821 	move	s3,zero
    }
  }*/

  while(1){
    for(i = 0; i < sizeof(imageHex); i++){
      for(j = 7; 0 <= j; j--){
9d0022f8:	5614fff1 	bnel	s0,s4,9d0022c0 <main+0x4c0>
9d0022fc:	92220000 	lbu	v0,0(s1)
9d002300:	26310001 	addiu	s1,s1,1
      }
    }
  }*/

  while(1){
    for(i = 0; i < sizeof(imageHex); i++){
9d002304:	12360003 	beq	s1,s6,9d002314 <main+0x514>
9d002308:	00000000 	nop

};// stores the binary image
  NU32_Startup();  // cache on, interrupts on, LED/button init, UART init
  display_init();
  int row, col, i, j, offset;
  row = 0;
9d00230c:	0b4008af 	j	9d0022bc <main+0x4bc>
9d002310:	24100007 	li	s0,7
          row++;
          col = 0;
        }
      }
    }
    display_draw();
9d002314:	0f4009fd 	jal	9d0027f4 <display_draw>
9d002318:	00008821 	move	s1,zero
          display_pixel_set(row, col, 1);
        }
        col++;
        if(col >= WIDTH){
          row++;
          col = 0;
9d00231c:	0b4008c9 	j	9d002324 <main+0x524>
9d002320:	00008021 	move	s0,zero
      }
    }
    display_draw();
    for(i = 0; i < WIDTH; i++){
      for(j = 0; j < HEIGHT; j++){
        display_pixel_set(j, i, 0);
9d002324:	02002021 	move	a0,s0
9d002328:	02202821 	move	a1,s1
9d00232c:	0f400a13 	jal	9d00284c <display_pixel_set>
9d002330:	00003021 	move	a2,zero
        }
      }
    }
    display_draw();
    for(i = 0; i < WIDTH; i++){
      for(j = 0; j < HEIGHT; j++){
9d002334:	26100001 	addiu	s0,s0,1
9d002338:	1612fffb 	bne	s0,s2,9d002328 <main+0x528>
9d00233c:	02002021 	move	a0,s0
          col = 0;
        }
      }
    }
    display_draw();
    for(i = 0; i < WIDTH; i++){
9d002340:	26310001 	addiu	s1,s1,1
9d002344:	52350003 	beql	s1,s5,9d002354 <main+0x554>
9d002348:	26f70001 	addiu	s7,s7,1
          display_pixel_set(row, col, 1);
        }
        col++;
        if(col >= WIDTH){
          row++;
          col = 0;
9d00234c:	0b4008c9 	j	9d002324 <main+0x524>
9d002350:	00008021 	move	s0,zero
      for(j = 0; j < HEIGHT; j++){
        display_pixel_set(j, i, 0);
      }
    }
    offset ++;
    if(offset > HEIGHT){
9d002354:	2ae20041 	slti	v0,s7,65
9d002358:	0b4008ac 	j	9d0022b0 <main+0x4b0>
9d00235c:	0002b80a 	movz	s7,zero,v0

9d002360 <I2C1MasterInterrupt>:
static volatile unsigned char address = 0; // the 7-bit address to write to / read from
static volatile unsigned int  n_write = 0; // number of data bytes to write
static volatile unsigned int  n_read  = 0; // number of data bytes to read


void __ISR(_I2C_1_VECTOR, IPL1SOFT) I2C1MasterInterrupt(void) {
9d002360:	415de800 	rdpgpr	sp,sp
9d002364:	401a7000 	mfc0	k0,c0_epc
9d002368:	401b6000 	mfc0	k1,c0_status
9d00236c:	27bdffe0 	addiu	sp,sp,-32
9d002370:	afba001c 	sw	k0,28(sp)
9d002374:	401a6002 	mfc0	k0,c0_srsctl
9d002378:	afbb0018 	sw	k1,24(sp)
9d00237c:	afba0014 	sw	k0,20(sp)
9d002380:	7c1b7844 	ins	k1,zero,0x1,0xf
9d002384:	377b0400 	ori	k1,k1,0x400
9d002388:	409b6000 	mtc0	k1,c0_status
9d00238c:	afa4000c 	sw	a0,12(sp)
9d002390:	afa30008 	sw	v1,8(sp)
9d002394:	afa20004 	sw	v0,4(sp)
  static unsigned int write_index = 0, read_index = 0;  //indexes the read/write arrays

  switch(state) {
9d002398:	8f82802c 	lw	v0,-32724(gp)
9d00239c:	2c430008 	sltiu	v1,v0,8
9d0023a0:	1060008d 	beqz	v1,9d0025d8 <I2C1MasterInterrupt+0x278>
9d0023a4:	00021080 	sll	v0,v0,0x2
9d0023a8:	3c039d00 	lui	v1,0x9d00
9d0023ac:	246323c0 	addiu	v1,v1,9152
9d0023b0:	00621021 	addu	v0,v1,v0
9d0023b4:	8c420000 	lw	v0,0(v0)
9d0023b8:	00400008 	jr	v0
9d0023bc:	00000000 	nop
9d0023c0:	9d0025d8 	0x9d0025d8
9d0023c4:	9d0023e0 	0x9d0023e0
9d0023c8:	9d002430 	0x9d002430
9d0023cc:	9d002500 	0x9d002500
9d0023d0:	9d0024d8 	0x9d0024d8
9d0023d4:	9d002584 	0x9d002584
9d0023d8:	9d0025a8 	0x9d0025a8
9d0023dc:	9d0025cc 	0x9d0025cc
    case START:                         // start bit has been sent
      write_index = 0;                  // reset indices
9d0023e0:	af808014 	sw	zero,-32748(gp)
      read_index = 0;
9d0023e4:	af808010 	sw	zero,-32752(gp)
      if(n_write > 0) {                 // there are bytes to write
9d0023e8:	8f82801c 	lw	v0,-32740(gp)
9d0023ec:	5040000a 	beqzl	v0,9d002418 <I2C1MasterInterrupt+0xb8>
9d0023f0:	24020005 	li	v0,5
        state = WRITE;                  // transition to write mode
9d0023f4:	24020002 	li	v0,2
9d0023f8:	af82802c 	sw	v0,-32724(gp)
        I2C1TRN = address << 1;         // send the address, with write mode set
9d0023fc:	93838020 	lbu	v1,-32736(gp)
9d002400:	306300ff 	andi	v1,v1,0xff
9d002404:	00031840 	sll	v1,v1,0x1
9d002408:	3c02bf80 	lui	v0,0xbf80
9d00240c:	ac435350 	sw	v1,21328(v0)
9d002410:	0b400979 	j	9d0025e4 <I2C1MasterInterrupt+0x284>
9d002414:	3c02bf88 	lui	v0,0xbf88
      } else {
        state = ACK;                    // skip directly to reading
9d002418:	af82802c 	sw	v0,-32724(gp)
        I2C1TRN = (address << 1) & 1;   
9d00241c:	93828020 	lbu	v0,-32736(gp)
9d002420:	3c02bf80 	lui	v0,0xbf80
9d002424:	ac405350 	sw	zero,21328(v0)
      break;
    default:
      // some error has occurred
      state = ERROR;
  }
  IFS0bits.I2C1MIF = 0;       //clear the interrupt flag
9d002428:	0b400979 	j	9d0025e4 <I2C1MasterInterrupt+0x284>
9d00242c:	3c02bf88 	lui	v0,0xbf88
        I2C1TRN = (address << 1) & 1;   
      }
      
      break;
    case WRITE:                         // a write has finished
      if(I2C1STATbits.ACKSTAT) {        // error: didn't receive an ACK from the slave
9d002430:	3c02bf80 	lui	v0,0xbf80
9d002434:	8c425310 	lw	v0,21264(v0)
9d002438:	30428000 	andi	v0,v0,0x8000
9d00243c:	50400005 	beqzl	v0,9d002454 <I2C1MasterInterrupt+0xf4>
9d002440:	8f828014 	lw	v0,-32748(gp)
        state = ERROR;
9d002444:	24020008 	li	v0,8
9d002448:	af82802c 	sw	v0,-32724(gp)
9d00244c:	0b400979 	j	9d0025e4 <I2C1MasterInterrupt+0x284>
9d002450:	3c02bf88 	lui	v0,0xbf88
      } else {        
        if(write_index < n_write) {         // still more data to write
9d002454:	8f83801c 	lw	v1,-32740(gp)
9d002458:	0043182b 	sltu	v1,v0,v1
9d00245c:	1060000a 	beqz	v1,9d002488 <I2C1MasterInterrupt+0x128>
9d002460:	00000000 	nop
          I2C1TRN = to_write[write_index];  // write the data
9d002464:	8f838028 	lw	v1,-32728(gp)
9d002468:	00621821 	addu	v1,v1,v0
9d00246c:	90640000 	lbu	a0,0(v1)
9d002470:	308400ff 	andi	a0,a0,0xff
9d002474:	3c03bf80 	lui	v1,0xbf80
9d002478:	ac645350 	sw	a0,21328(v1)
          ++write_index;
9d00247c:	24420001 	addiu	v0,v0,1
9d002480:	0b400978 	j	9d0025e0 <I2C1MasterInterrupt+0x280>
9d002484:	af828014 	sw	v0,-32748(gp)
        } else {                            // done writing data, time to read or stop
          if(n_read > 0) {                  // we want to read so issue a restart
9d002488:	8f828018 	lw	v0,-32744(gp)
9d00248c:	5040000a 	beqzl	v0,9d0024b8 <I2C1MasterInterrupt+0x158>
9d002490:	24020007 	li	v0,7
            state = RESTART;         
9d002494:	24020004 	li	v0,4
9d002498:	af82802c 	sw	v0,-32724(gp)
            I2C1CONbits.RSEN = 1;           // send the restart to begin the read
9d00249c:	3c02bf80 	lui	v0,0xbf80
9d0024a0:	94435300 	lhu	v1,21248(v0)
9d0024a4:	24040001 	li	a0,1
9d0024a8:	7c830844 	ins	v1,a0,0x1,0x1
9d0024ac:	a4435300 	sh	v1,21248(v0)
9d0024b0:	0b400979 	j	9d0025e4 <I2C1MasterInterrupt+0x284>
9d0024b4:	3c02bf88 	lui	v0,0xbf88
          } else {                          // no data to read, issue a stop
            state = STOP;
9d0024b8:	af82802c 	sw	v0,-32724(gp)
            I2C1CONbits.PEN = 1;
9d0024bc:	3c02bf80 	lui	v0,0xbf80
9d0024c0:	94435300 	lhu	v1,21248(v0)
9d0024c4:	24040001 	li	a0,1
9d0024c8:	7c831084 	ins	v1,a0,0x2,0x1
9d0024cc:	a4435300 	sh	v1,21248(v0)
      break;
    default:
      // some error has occurred
      state = ERROR;
  }
  IFS0bits.I2C1MIF = 0;       //clear the interrupt flag
9d0024d0:	0b400979 	j	9d0025e4 <I2C1MasterInterrupt+0x284>
9d0024d4:	3c02bf88 	lui	v0,0xbf88
        }
      }
      break;
    case RESTART: // the restart has completed
      // now we want to read, send the read address
      state = ACK;       // when interrupted in ACK mode, we will initiate reading a byte
9d0024d8:	24020005 	li	v0,5
9d0024dc:	af82802c 	sw	v0,-32724(gp)
      I2C1TRN = (address << 1) | 1; // the address is sent with the read bit sent
9d0024e0:	93838020 	lbu	v1,-32736(gp)
9d0024e4:	306300ff 	andi	v1,v1,0xff
9d0024e8:	00031840 	sll	v1,v1,0x1
9d0024ec:	34630001 	ori	v1,v1,0x1
9d0024f0:	3c02bf80 	lui	v0,0xbf80
9d0024f4:	ac435350 	sw	v1,21328(v0)
      break;
9d0024f8:	0b400979 	j	9d0025e4 <I2C1MasterInterrupt+0x284>
9d0024fc:	3c02bf88 	lui	v0,0xbf88
    case READ:
      to_read[read_index] = I2C1RCV;
9d002500:	8f838024 	lw	v1,-32732(gp)
9d002504:	8f828010 	lw	v0,-32752(gp)
9d002508:	00621821 	addu	v1,v1,v0
9d00250c:	3c04bf80 	lui	a0,0xbf80
9d002510:	8c845360 	lw	a0,21344(a0)
9d002514:	308400ff 	andi	a0,a0,0xff
9d002518:	a0640000 	sb	a0,0(v1)
      ++read_index;
9d00251c:	24420001 	addiu	v0,v0,1
9d002520:	af828010 	sw	v0,-32752(gp)
      if(read_index == n_read) { // we are done reading, so send a nack
9d002524:	8f838018 	lw	v1,-32744(gp)
9d002528:	5443000a 	bnel	v0,v1,9d002554 <I2C1MasterInterrupt+0x1f4>
9d00252c:	24020005 	li	v0,5
        state = NACK;
9d002530:	24020006 	li	v0,6
9d002534:	af82802c 	sw	v0,-32724(gp)
        I2C1CONbits.ACKDT = 1;
9d002538:	3c02bf80 	lui	v0,0xbf80
9d00253c:	94435300 	lhu	v1,21248(v0)
9d002540:	24040001 	li	a0,1
9d002544:	7c832944 	ins	v1,a0,0x5,0x1
9d002548:	a4435300 	sh	v1,21248(v0)
9d00254c:	0b40095b 	j	9d00256c <I2C1MasterInterrupt+0x20c>
9d002550:	3c02bf80 	lui	v0,0xbf80
      } else {
        state = ACK;
9d002554:	af82802c 	sw	v0,-32724(gp)
        I2C1CONbits.ACKDT = 0;
9d002558:	3c02bf80 	lui	v0,0xbf80
9d00255c:	94435300 	lhu	v1,21248(v0)
9d002560:	7c032944 	ins	v1,zero,0x5,0x1
9d002564:	a4435300 	sh	v1,21248(v0)
      }
      I2C1CONbits.ACKEN = 1;
9d002568:	3c02bf80 	lui	v0,0xbf80
9d00256c:	94435300 	lhu	v1,21248(v0)
9d002570:	24040001 	li	a0,1
9d002574:	7c832104 	ins	v1,a0,0x4,0x1
9d002578:	a4435300 	sh	v1,21248(v0)
      break;
9d00257c:	0b400979 	j	9d0025e4 <I2C1MasterInterrupt+0x284>
9d002580:	3c02bf88 	lui	v0,0xbf88
    case ACK:
              // just sent an ack meaning we want to read more bytes
      state = READ;
9d002584:	24020003 	li	v0,3
9d002588:	af82802c 	sw	v0,-32724(gp)
      I2C1CONbits.RCEN = 1;
9d00258c:	3c02bf80 	lui	v0,0xbf80
9d002590:	94435300 	lhu	v1,21248(v0)
9d002594:	24040001 	li	a0,1
9d002598:	7c8318c4 	ins	v1,a0,0x3,0x1
9d00259c:	a4435300 	sh	v1,21248(v0)
      break;
9d0025a0:	0b400979 	j	9d0025e4 <I2C1MasterInterrupt+0x284>
9d0025a4:	3c02bf88 	lui	v0,0xbf88
    case NACK:
      //issue a stop
      state = STOP;
9d0025a8:	24020007 	li	v0,7
9d0025ac:	af82802c 	sw	v0,-32724(gp)
      I2C1CONbits.PEN = 1;
9d0025b0:	3c02bf80 	lui	v0,0xbf80
9d0025b4:	94435300 	lhu	v1,21248(v0)
9d0025b8:	24040001 	li	a0,1
9d0025bc:	7c831084 	ins	v1,a0,0x2,0x1
9d0025c0:	a4435300 	sh	v1,21248(v0)
      break;
9d0025c4:	0b400979 	j	9d0025e4 <I2C1MasterInterrupt+0x284>
9d0025c8:	3c02bf88 	lui	v0,0xbf88
    case STOP:
      state = IDLE; // we have returned to idle mode, indicating that the data is ready
9d0025cc:	af80802c 	sw	zero,-32724(gp)
      break;
9d0025d0:	0b400979 	j	9d0025e4 <I2C1MasterInterrupt+0x284>
9d0025d4:	3c02bf88 	lui	v0,0xbf88
    default:
      // some error has occurred
      state = ERROR;
9d0025d8:	24020008 	li	v0,8
9d0025dc:	af82802c 	sw	v0,-32724(gp)
  }
  IFS0bits.I2C1MIF = 0;       //clear the interrupt flag
9d0025e0:	3c02bf88 	lui	v0,0xbf88
9d0025e4:	8c431030 	lw	v1,4144(v0)
9d0025e8:	7c03ffc4 	ins	v1,zero,0x1f,0x1
9d0025ec:	ac431030 	sw	v1,4144(v0)
}
9d0025f0:	8fa4000c 	lw	a0,12(sp)
9d0025f4:	8fa30008 	lw	v1,8(sp)
9d0025f8:	8fa20004 	lw	v0,4(sp)
9d0025fc:	41606000 	di
9d002600:	000000c0 	ehb
9d002604:	8fba001c 	lw	k0,28(sp)
9d002608:	8fbb0018 	lw	k1,24(sp)
9d00260c:	409a7000 	mtc0	k0,c0_epc
9d002610:	8fba0014 	lw	k0,20(sp)
9d002614:	27bd0020 	addiu	sp,sp,32
9d002618:	409a6002 	mtc0	k0,c0_srsctl
9d00261c:	41dde800 	wrpgpr	sp,sp
9d002620:	409b6000 	mtc0	k1,c0_status
9d002624:	42000018 	eret

9d002628 <i2c_master_setup>:

void i2c_master_setup() {
9d002628:	27bdfff8 	addiu	sp,sp,-8
9d00262c:	afbf0004 	sw	ra,4(sp)
  int ie = __builtin_disable_interrupts();
9d002630:	41656000 	di	a1
9d002634:	000000c0 	ehb
  I2C1BRG = 90;                    // I2CBRG = [1/(2*Fsck) - PGD]*Pblck - 2
9d002638:	2403005a 	li	v1,90
9d00263c:	3c02bf80 	lui	v0,0xbf80
9d002640:	ac435340 	sw	v1,21312(v0)
                                   // Fsck is the frequency (400 kHz here), PGD = 104ns
                                   // this is 400 khz mode
                                   // enable the i2c interrupts
  IPC6bits.I2C1IP  = 1;            // master has interrupt priority 1
9d002644:	3c03bf88 	lui	v1,0xbf88
9d002648:	8c6410f0 	lw	a0,4336(v1)
9d00264c:	24020001 	li	v0,1
9d002650:	7c446284 	ins	a0,v0,0xa,0x3
9d002654:	ac6410f0 	sw	a0,4336(v1)
  IEC0bits.I2C1MIE = 1;            // master interrupt is enabled
9d002658:	3c03bf88 	lui	v1,0xbf88
9d00265c:	8c641060 	lw	a0,4192(v1)
9d002660:	7c44ffc4 	ins	a0,v0,0x1f,0x1
9d002664:	ac641060 	sw	a0,4192(v1)
  IFS0bits.I2C1MIF = 0;            // clear the interrupt flag
9d002668:	3c03bf88 	lui	v1,0xbf88
9d00266c:	8c641030 	lw	a0,4144(v1)
9d002670:	7c04ffc4 	ins	a0,zero,0x1f,0x1
9d002674:	ac641030 	sw	a0,4144(v1)
  I2C1CONbits.ON = 1;              // turn on the I2C2 module
9d002678:	3c03bf80 	lui	v1,0xbf80
9d00267c:	94645300 	lhu	a0,21248(v1)
9d002680:	7c447bc4 	ins	a0,v0,0xf,0x1
9d002684:	a4645300 	sh	a0,21248(v1)
  
  if(ie & 1) {
9d002688:	30a20001 	andi	v0,a1,0x1
9d00268c:	10400003 	beqz	v0,9d00269c <i2c_master_setup+0x74>
9d002690:	8fbf0004 	lw	ra,4(sp)
    __builtin_enable_interrupts();
9d002694:	41626020 	ei	v0
  }
}
9d002698:	8fbf0004 	lw	ra,4(sp)
9d00269c:	03e00008 	jr	ra
9d0026a0:	27bd0008 	addiu	sp,sp,8

9d0026a4 <i2c_write_read>:

// communicate with the slave at address addr.  first write wlen bytes to the slave, 
// then read rlen bytes from the slave
int i2c_write_read(unsigned int addr, const buffer_t write, 
    unsigned int wlen, const buffer_t read, unsigned int rlen ) {
9d0026a4:	afa50004 	sw	a1,4(sp)
9d0026a8:	afa7000c 	sw	a3,12(sp)
  n_write = wlen;
9d0026ac:	af86801c 	sw	a2,-32740(gp)
  n_read = rlen;
9d0026b0:	8fa20010 	lw	v0,16(sp)
9d0026b4:	af828018 	sw	v0,-32744(gp)
  to_write = write;
9d0026b8:	8fa20004 	lw	v0,4(sp)
9d0026bc:	af828028 	sw	v0,-32728(gp)
  to_read = read;
9d0026c0:	8fa2000c 	lw	v0,12(sp)
9d0026c4:	af828024 	sw	v0,-32732(gp)
  address = addr;
9d0026c8:	308400ff 	andi	a0,a0,0xff
9d0026cc:	a3848020 	sb	a0,-32736(gp)
  state = START;
9d0026d0:	24040001 	li	a0,1
9d0026d4:	af84802c 	sw	a0,-32724(gp)
  I2C1CONbits.SEN = 1;        // initialize the start
9d0026d8:	3c02bf80 	lui	v0,0xbf80
9d0026dc:	94435300 	lhu	v1,21248(v0)
9d0026e0:	7c830004 	ins	v1,a0,0x0,0x1
9d0026e4:	a4435300 	sh	v1,21248(v0)
  while(state != IDLE && state != ERROR) { ; }  // initialize the sequence
9d0026e8:	24030008 	li	v1,8
9d0026ec:	8f82802c 	lw	v0,-32724(gp)
9d0026f0:	10400004 	beqz	v0,9d002704 <i2c_write_read+0x60>
9d0026f4:	00000000 	nop
9d0026f8:	8f82802c 	lw	v0,-32724(gp)
9d0026fc:	1443fffb 	bne	v0,v1,9d0026ec <i2c_write_read+0x48>
9d002700:	00000000 	nop
  return state != ERROR;
9d002704:	8f82802c 	lw	v0,-32724(gp)
9d002708:	38420008 	xori	v0,v0,0x8
}
9d00270c:	03e00008 	jr	ra
9d002710:	0002102b 	sltu	v0,zero,v0

9d002714 <i2c_write_byte>:

// write a single byte to the slave
int i2c_write_byte(unsigned int addr, unsigned char byte) {
9d002714:	27bdffe0 	addiu	sp,sp,-32
9d002718:	afbf001c 	sw	ra,28(sp)
9d00271c:	a3a50024 	sb	a1,36(sp)
  return i2c_write_read(addr,&byte,1,NULL,0);
9d002720:	afa00010 	sw	zero,16(sp)
9d002724:	27a50024 	addiu	a1,sp,36
9d002728:	24060001 	li	a2,1
9d00272c:	0f4009a9 	jal	9d0026a4 <i2c_write_read>
9d002730:	00003821 	move	a3,zero
}
9d002734:	8fbf001c 	lw	ra,28(sp)
9d002738:	03e00008 	jr	ra
9d00273c:	27bd0020 	addiu	sp,sp,32

Disassembly of section .text:

9d002740 <display_command>:
static unsigned char * gddram = video_buffer + 1; // the video buffer start, excluding 
                                                  // address byte we write these pixels 
                                                  // to GDDRAM over I2C


void display_command(unsigned char cmd) {// write a command to the display
9d002740:	27bdffd8 	addiu	sp,sp,-40
9d002744:	afbf0024 	sw	ra,36(sp)
  unsigned char to_write[] = {0x00,cmd}; // 1st byte = 0 (CO = 0, DC = 0), 2nd is command
9d002748:	a3a00018 	sb	zero,24(sp)
9d00274c:	a3a40019 	sb	a0,25(sp)
  i2c_write_read(DISPLAY_ADDR, to_write,2, NULL, 0); 
9d002750:	afa00010 	sw	zero,16(sp)
9d002754:	2404003c 	li	a0,60
9d002758:	27a50018 	addiu	a1,sp,24
9d00275c:	24060002 	li	a2,2
9d002760:	0f4009a9 	jal	9d0026a4 <i2c_write_read>
9d002764:	00003821 	move	a3,zero
}
9d002768:	8fbf0024 	lw	ra,36(sp)
9d00276c:	03e00008 	jr	ra
9d002770:	27bd0028 	addiu	sp,sp,40

9d002774 <display_init>:

void display_init() {
9d002774:	27bdffe8 	addiu	sp,sp,-24
9d002778:	afbf0014 	sw	ra,20(sp)
  i2c_master_setup();     
9d00277c:	0f40098a 	jal	9d002628 <i2c_master_setup>
9d002780:	00000000 	nop
                          // goes through the reset procedure
  display_command(0xAE);  // turn off display
9d002784:	0f4009d0 	jal	9d002740 <display_command>
9d002788:	240400ae 	li	a0,174

  display_command(0xA8);     // set the multiplex ratio (how many rows are updated per
9d00278c:	0f4009d0 	jal	9d002740 <display_command>
9d002790:	240400a8 	li	a0,168
                             // oled driver clock) to the number of rows in the display
  display_command(HEIGHT-1); // the ratio set is the value sent+1, so subtract 1
9d002794:	0f4009d0 	jal	9d002740 <display_command>
9d002798:	2404003f 	li	a0,63

                         // we will always write the full display on a single update.
  display_command(0x20); // set address mode
9d00279c:	0f4009d0 	jal	9d002740 <display_command>
9d0027a0:	24040020 	li	a0,32
  display_command(0x00); // horizontal address mode
9d0027a4:	0f4009d0 	jal	9d002740 <display_command>
9d0027a8:	00002021 	move	a0,zero
  display_command(0x21); // set column address
9d0027ac:	0f4009d0 	jal	9d002740 <display_command>
9d0027b0:	24040021 	li	a0,33
  display_command(0x00); // start at 0
9d0027b4:	0f4009d0 	jal	9d002740 <display_command>
9d0027b8:	00002021 	move	a0,zero
  display_command(0xFF); // end at 127
9d0027bc:	0f4009d0 	jal	9d002740 <display_command>
9d0027c0:	240400ff 	li	a0,255
                         // with this address mode, the address will go through all 
                         // the pixels and then return to the start,
                         // hence we never need to set the address again

  display_command(0x8d); // charge pump
9d0027c4:	0f4009d0 	jal	9d002740 <display_command>
9d0027c8:	2404008d 	li	a0,141
  display_command(0x14); // turn on charge pump to create ~7 Volts needed to light pixels
9d0027cc:	0f4009d0 	jal	9d002740 <display_command>
9d0027d0:	24040014 	li	a0,20
  display_command(0xAF); // turn on the display
9d0027d4:	0f4009d0 	jal	9d002740 <display_command>
9d0027d8:	240400af 	li	a0,175
  video_buffer[0] = 0x40;// co = 0, dc =1, allows us to send data directly from video 
9d0027dc:	24030040 	li	v1,64
9d0027e0:	3c02a000 	lui	v0,0xa000
9d0027e4:	a0430020 	sb	v1,32(v0)
                         // buffer, 0x40 is the "next bytes have data" byte
}
9d0027e8:	8fbf0014 	lw	ra,20(sp)
9d0027ec:	03e00008 	jr	ra
9d0027f0:	27bd0018 	addiu	sp,sp,24

9d0027f4 <display_draw>:

void display_draw() {    // copies data to the gddram on the oled chip
9d0027f4:	27bdffe0 	addiu	sp,sp,-32
9d0027f8:	afbf001c 	sw	ra,28(sp)
  i2c_write_read(DISPLAY_ADDR, video_buffer, SIZE + 1, NULL, 0);
9d0027fc:	afa00010 	sw	zero,16(sp)
9d002800:	2404003c 	li	a0,60
9d002804:	3c05a000 	lui	a1,0xa000
9d002808:	24a50020 	addiu	a1,a1,32
9d00280c:	24060401 	li	a2,1025
9d002810:	0f4009a9 	jal	9d0026a4 <i2c_write_read>
9d002814:	00003821 	move	a3,zero
}
9d002818:	8fbf001c 	lw	ra,28(sp)
9d00281c:	03e00008 	jr	ra
9d002820:	27bd0020 	addiu	sp,sp,32

9d002824 <display_clear>:

void display_clear() {
9d002824:	27bdffe8 	addiu	sp,sp,-24
9d002828:	afbf0014 	sw	ra,20(sp)
  memset(gddram,0,SIZE);
9d00282c:	3c04a000 	lui	a0,0xa000
9d002830:	24840021 	addiu	a0,a0,33
9d002834:	00002821 	move	a1,zero
9d002838:	0f400af8 	jal	9d002be0 <memset>
9d00283c:	24060400 	li	a2,1024
}
9d002840:	8fbf0014 	lw	ra,20(sp)
9d002844:	03e00008 	jr	ra
9d002848:	27bd0018 	addiu	sp,sp,24

9d00284c <display_pixel_set>:
  return 1 << (row % 8);
}

// invert the pixel at the given row and column
void display_pixel_set(int row, int col,int val) { 
  if(val) { 
9d00284c:	10c00014 	beqz	a2,9d0028a0 <display_pixel_set+0x54>
9d002850:	24820007 	addiu	v0,a0,7
  memset(gddram,0,SIZE);
}

// get the position in gddram of the pixel position
static inline int pixel_pos(int row, int col) { 
  return (row/8)*WIDTH + col;
9d002854:	28830000 	slti	v1,a0,0
9d002858:	0083100a 	movz	v0,a0,v1
9d00285c:	000210c3 	sra	v0,v0,0x3
9d002860:	000211c0 	sll	v0,v0,0x7
9d002864:	00a22821 	addu	a1,a1,v0
}

// invert the pixel at the given row and column
void display_pixel_set(int row, int col,int val) { 
  if(val) { 
    gddram[pixel_pos(row,col)] |= pixel_mask(row);   // set the pixel
9d002868:	3c02a000 	lui	v0,0xa000
9d00286c:	24420021 	addiu	v0,v0,33
9d002870:	00452821 	addu	a1,v0,a1
  return (row/8)*WIDTH + col;
}

// get a bitmask for the actual pixel position, based on row
static inline unsigned char pixel_mask(int row) { 
  return 1 << (row % 8);
9d002874:	000417c3 	sra	v0,a0,0x1f
9d002878:	00021742 	srl	v0,v0,0x1d
9d00287c:	00822021 	addu	a0,a0,v0
9d002880:	30840007 	andi	a0,a0,0x7
9d002884:	00821023 	subu	v0,a0,v0
9d002888:	24030001 	li	v1,1
9d00288c:	00431004 	sllv	v0,v1,v0
}

// invert the pixel at the given row and column
void display_pixel_set(int row, int col,int val) { 
  if(val) { 
    gddram[pixel_pos(row,col)] |= pixel_mask(row);   // set the pixel
9d002890:	90a30000 	lbu	v1,0(a1)
9d002894:	00431025 	or	v0,v0,v1
9d002898:	03e00008 	jr	ra
9d00289c:	a0a20000 	sb	v0,0(a1)
  memset(gddram,0,SIZE);
}

// get the position in gddram of the pixel position
static inline int pixel_pos(int row, int col) { 
  return (row/8)*WIDTH + col;
9d0028a0:	28830000 	slti	v1,a0,0
9d0028a4:	0083100a 	movz	v0,a0,v1
9d0028a8:	000210c3 	sra	v0,v0,0x3
9d0028ac:	000211c0 	sll	v0,v0,0x7
9d0028b0:	00a22821 	addu	a1,a1,v0
// invert the pixel at the given row and column
void display_pixel_set(int row, int col,int val) { 
  if(val) { 
    gddram[pixel_pos(row,col)] |= pixel_mask(row);   // set the pixel
  } else {
    gddram[pixel_pos(row,col)] &= ~pixel_mask(row);  // clear the pixel
9d0028b4:	3c02a000 	lui	v0,0xa000
9d0028b8:	24420021 	addiu	v0,v0,33
9d0028bc:	00452821 	addu	a1,v0,a1
  return (row/8)*WIDTH + col;
}

// get a bitmask for the actual pixel position, based on row
static inline unsigned char pixel_mask(int row) { 
  return 1 << (row % 8);
9d0028c0:	000417c3 	sra	v0,a0,0x1f
9d0028c4:	00021742 	srl	v0,v0,0x1d
9d0028c8:	00822021 	addu	a0,a0,v0
9d0028cc:	30840007 	andi	a0,a0,0x7
9d0028d0:	00821023 	subu	v0,a0,v0
9d0028d4:	24030001 	li	v1,1
9d0028d8:	00431004 	sllv	v0,v1,v0
// invert the pixel at the given row and column
void display_pixel_set(int row, int col,int val) { 
  if(val) { 
    gddram[pixel_pos(row,col)] |= pixel_mask(row);   // set the pixel
  } else {
    gddram[pixel_pos(row,col)] &= ~pixel_mask(row);  // clear the pixel
9d0028dc:	00021027 	nor	v0,zero,v0
9d0028e0:	90a30000 	lbu	v1,0(a1)
9d0028e4:	00431024 	and	v0,v0,v1
9d0028e8:	03e00008 	jr	ra
9d0028ec:	a0a20000 	sb	v0,0(a1)

9d0028f0 <display_pixel_get>:
  memset(gddram,0,SIZE);
}

// get the position in gddram of the pixel position
static inline int pixel_pos(int row, int col) { 
  return (row/8)*WIDTH + col;
9d0028f0:	24820007 	addiu	v0,a0,7
9d0028f4:	28830000 	slti	v1,a0,0
9d0028f8:	0083100a 	movz	v0,a0,v1
9d0028fc:	000210c3 	sra	v0,v0,0x3
    gddram[pixel_pos(row,col)] &= ~pixel_mask(row);  // clear the pixel
  }
}

int display_pixel_get(int row, int col) {
  return (gddram[pixel_pos(row,col)] & pixel_mask(row)) != 0;
9d002900:	000211c0 	sll	v0,v0,0x7
9d002904:	00452821 	addu	a1,v0,a1
9d002908:	3c03a000 	lui	v1,0xa000
9d00290c:	24630021 	addiu	v1,v1,33
9d002910:	00a32821 	addu	a1,a1,v1
  return (row/8)*WIDTH + col;
}

// get a bitmask for the actual pixel position, based on row
static inline unsigned char pixel_mask(int row) { 
  return 1 << (row % 8);
9d002914:	000417c3 	sra	v0,a0,0x1f
9d002918:	00021742 	srl	v0,v0,0x1d
9d00291c:	00822021 	addu	a0,a0,v0
9d002920:	30840007 	andi	a0,a0,0x7
9d002924:	00821023 	subu	v0,a0,v0
9d002928:	24030001 	li	v1,1
9d00292c:	00431004 	sllv	v0,v1,v0
    gddram[pixel_pos(row,col)] &= ~pixel_mask(row);  // clear the pixel
  }
}

int display_pixel_get(int row, int col) {
  return (gddram[pixel_pos(row,col)] & pixel_mask(row)) != 0;
9d002930:	90a30000 	lbu	v1,0(a1)
9d002934:	00431024 	and	v0,v0,v1
}
9d002938:	03e00008 	jr	ra
9d00293c:	0002102b 	sltu	v0,zero,v0

9d002940 <NU32_Startup>:

// Perform startup routines:
//  Make NU32_LED1 and NU32_LED2 pins outputs (NU32_USER is by default an input)
//  Initialize the serial port - UART3 (no interrupt) 
//  Enable interrupts
void NU32_Startup() {
9d002940:	27bdfff8 	addiu	sp,sp,-8
9d002944:	afbf0004 	sw	ra,4(sp)
  // disable interrupts
  __builtin_disable_interrupts();
9d002948:	41626000 	di	v0
9d00294c:	000000c0 	ehb
  // see Chapter 2 "CPU for Devices with M4K Core" of the PIC32 reference manual
  // most of the other bits have prescribed values
  // microchip does not provide a _CP0_SET_CONFIG macro, so we directly use
  // the compiler built-in command _mtc0
  // to disable cache, use 0xa4210582 
  __builtin_mtc0(_CP0_CONFIG, _CP0_CONFIG_SELECT, 0xa4210583); 
9d002950:	3c02a421 	lui	v0,0xa421
9d002954:	24420583 	addiu	v0,v0,1411
9d002958:	40828000 	mtc0	v0,c0_config
9d00295c:	000000c0 	ehb
  
  // set the prefectch cache wait state to 2, as per the
  // electrical characteristics data sheet
  CHECONbits.PFMWS = 0x2;   
9d002960:	3c02bf88 	lui	v0,0xbf88
9d002964:	8c434000 	lw	v1,16384(v0)
9d002968:	24050002 	li	a1,2
9d00296c:	7ca31004 	ins	v1,a1,0x0,0x3
9d002970:	ac434000 	sw	v1,16384(v0)

  //enable prefetch for cacheable and noncacheable memory
  CHECONbits.PREFEN = 0x3; 
9d002974:	8c434000 	lw	v1,16384(v0)
9d002978:	24040003 	li	a0,3
9d00297c:	7c832904 	ins	v1,a0,0x4,0x2
9d002980:	ac434000 	sw	v1,16384(v0)

  // 0 data RAM access wait states
  BMXCONbits.BMXWSDRM = 0x0;
9d002984:	3c02bf88 	lui	v0,0xbf88
9d002988:	8c432000 	lw	v1,8192(v0)
9d00298c:	7c033184 	ins	v1,zero,0x6,0x1
9d002990:	ac432000 	sw	v1,8192(v0)
  
  // enable multi vector interrupts
  INTCONbits.MVEC = 0x1;
9d002994:	3c02bf88 	lui	v0,0xbf88
9d002998:	8c461000 	lw	a2,4096(v0)
9d00299c:	24030001 	li	v1,1
9d0029a0:	7c666304 	ins	a2,v1,0xc,0x1
9d0029a4:	ac461000 	sw	a2,4096(v0)

  // disable JTAG to get B10, B11, B12 and B13 back
  DDPCONbits.JTAGEN = 0;
9d0029a8:	3c02bf81 	lui	v0,0xbf81
9d0029ac:	9046f200 	lbu	a2,-3584(v0)
9d0029b0:	7c0618c4 	ins	a2,zero,0x3,0x1
9d0029b4:	a046f200 	sb	a2,-3584(v0)

  TRISFCLR = 0x0003;  // Make F0 and F1 outputs (LED1 and LED2)
9d0029b8:	3c02bf88 	lui	v0,0xbf88
9d0029bc:	ac446144 	sw	a0,24900(v0)
  NU32_LED1 = 1;      // LED1 is off
9d0029c0:	3c02bf88 	lui	v0,0xbf88
9d0029c4:	90446160 	lbu	a0,24928(v0)
9d0029c8:	7c640004 	ins	a0,v1,0x0,0x1
9d0029cc:	a0446160 	sb	a0,24928(v0)
  NU32_LED2 = 0;      // LED2 is on
9d0029d0:	90446160 	lbu	a0,24928(v0)
9d0029d4:	7c040844 	ins	a0,zero,0x1,0x1
9d0029d8:	a0446160 	sb	a0,24928(v0)

  // turn on UART3 without an interrupt
  U3MODEbits.BRGH = 0; // set baud to NU32_DESIRED_BAUD
9d0029dc:	3c02bf80 	lui	v0,0xbf80
9d0029e0:	94446400 	lhu	a0,25600(v0)
9d0029e4:	7c0418c4 	ins	a0,zero,0x3,0x1
9d0029e8:	a4446400 	sh	a0,25600(v0)
  U3BRG = ((NU32_SYS_FREQ / NU32_DESIRED_BAUD) / 16) - 1;
9d0029ec:	24060014 	li	a2,20
9d0029f0:	3c04bf80 	lui	a0,0xbf80
9d0029f4:	ac866440 	sw	a2,25664(a0)

  // 8 bit, no parity bit, and 1 stop bit (8N1 setup)
  U3MODEbits.PDSEL = 0;
9d0029f8:	94446400 	lhu	a0,25600(v0)
9d0029fc:	7c041044 	ins	a0,zero,0x1,0x2
9d002a00:	a4446400 	sh	a0,25600(v0)
  U3MODEbits.STSEL = 0;
9d002a04:	94446400 	lhu	a0,25600(v0)
9d002a08:	7c040004 	ins	a0,zero,0x0,0x1
9d002a0c:	a4446400 	sh	a0,25600(v0)

  // configure TX & RX pins as output & input pins
  U3STAbits.UTXEN = 1;
9d002a10:	3c04bf80 	lui	a0,0xbf80
9d002a14:	8c866410 	lw	a2,25616(a0)
9d002a18:	7c665284 	ins	a2,v1,0xa,0x1
9d002a1c:	ac866410 	sw	a2,25616(a0)
  U3STAbits.URXEN = 1;
9d002a20:	8c866410 	lw	a2,25616(a0)
9d002a24:	7c666304 	ins	a2,v1,0xc,0x1
9d002a28:	ac866410 	sw	a2,25616(a0)
  // configure hardware flow control using RTS and CTS
  U3MODEbits.UEN = 2;
9d002a2c:	94446400 	lhu	a0,25600(v0)
9d002a30:	7ca44a04 	ins	a0,a1,0x8,0x2
9d002a34:	a4446400 	sh	a0,25600(v0)

  // enable the uart
  U3MODEbits.ON = 1;
9d002a38:	94446400 	lhu	a0,25600(v0)
9d002a3c:	7c647bc4 	ins	a0,v1,0xf,0x1
9d002a40:	a4446400 	sh	a0,25600(v0)

  __builtin_enable_interrupts();
9d002a44:	41626020 	ei	v0
}
9d002a48:	8fbf0004 	lw	ra,4(sp)
9d002a4c:	03e00008 	jr	ra
9d002a50:	27bd0008 	addiu	sp,sp,8

9d002a54 <NU32_ReadUART3>:
// Read from UART3
// block other functions until you get a '\r' or '\n'
// send the pointer to your char array and the number of elements in the array
void NU32_ReadUART3(char * message, int maxLength) {
  char data = 0;
  int complete = 0, num_bytes = 0;
9d002a54:	00003021 	move	a2,zero
  // loop until you get a '\r' or '\n'
  while (!complete) {
    if (U3STAbits.URXDA) { // if data is available
9d002a58:	3c03bf80 	lui	v1,0xbf80
      data = U3RXREG;      // read the data
9d002a5c:	3c08bf80 	lui	t0,0xbf80
      if ((data == '\n') || (data == '\r')) {
9d002a60:	2407000a 	li	a3,10
9d002a64:	0b400aa9 	j	9d002aa4 <NU32_ReadUART3+0x50>
9d002a68:	2409000d 	li	t1,13
void NU32_ReadUART3(char * message, int maxLength) {
  char data = 0;
  int complete = 0, num_bytes = 0;
  // loop until you get a '\r' or '\n'
  while (!complete) {
    if (U3STAbits.URXDA) { // if data is available
9d002a6c:	8c626410 	lw	v0,25616(v1)
9d002a70:	30420001 	andi	v0,v0,0x1
9d002a74:	1040fffd 	beqz	v0,9d002a6c <NU32_ReadUART3+0x18>
9d002a78:	00000000 	nop
      data = U3RXREG;      // read the data
9d002a7c:	8d026430 	lw	v0,25648(t0)
9d002a80:	7c021420 	seb	v0,v0
      if ((data == '\n') || (data == '\r')) {
9d002a84:	5047000e 	beql	v0,a3,9d002ac0 <NU32_ReadUART3+0x6c>
9d002a88:	00862021 	addu	a0,a0,a2
9d002a8c:	1049000b 	beq	v0,t1,9d002abc <NU32_ReadUART3+0x68>
9d002a90:	00865021 	addu	t2,a0,a2
        complete = 1;
      } else {
        message[num_bytes] = data;
9d002a94:	a1420000 	sb	v0,0(t2)
        ++num_bytes;
9d002a98:	24c60001 	addiu	a2,a2,1
        // roll over if the array is too small
        if (num_bytes >= maxLength) {
9d002a9c:	00c5102a 	slt	v0,a2,a1
          num_bytes = 0;
9d002aa0:	0002300a 	movz	a2,zero,v0
void NU32_ReadUART3(char * message, int maxLength) {
  char data = 0;
  int complete = 0, num_bytes = 0;
  // loop until you get a '\r' or '\n'
  while (!complete) {
    if (U3STAbits.URXDA) { // if data is available
9d002aa4:	8c626410 	lw	v0,25616(v1)
9d002aa8:	30420001 	andi	v0,v0,0x1
9d002aac:	1040ffef 	beqz	v0,9d002a6c <NU32_ReadUART3+0x18>
9d002ab0:	00000000 	nop
9d002ab4:	0b400a9f 	j	9d002a7c <NU32_ReadUART3+0x28>
9d002ab8:	00000000 	nop
        }
      }
    }
  }
  // end the string
  message[num_bytes] = '\0';
9d002abc:	00862021 	addu	a0,a0,a2
9d002ac0:	03e00008 	jr	ra
9d002ac4:	a0800000 	sb	zero,0(a0)

9d002ac8 <NU32_WriteUART3>:
}

// Write a character array using UART3
void NU32_WriteUART3(const char * string) {
  while (*string != '\0') {
9d002ac8:	80850000 	lb	a1,0(a0)
9d002acc:	10a0000b 	beqz	a1,9d002afc <NU32_WriteUART3+0x34>
9d002ad0:	3c03bf80 	lui	v1,0xbf80
    while (U3STAbits.UTXBF) {
      ; // wait until tx buffer isn't full
    }
    U3TXREG = *string;
9d002ad4:	3c06bf80 	lui	a2,0xbf80
}

// Write a character array using UART3
void NU32_WriteUART3(const char * string) {
  while (*string != '\0') {
    while (U3STAbits.UTXBF) {
9d002ad8:	8c626410 	lw	v0,25616(v1)
9d002adc:	30420200 	andi	v0,v0,0x200
9d002ae0:	1440fffd 	bnez	v0,9d002ad8 <NU32_WriteUART3+0x10>
9d002ae4:	00000000 	nop
      ; // wait until tx buffer isn't full
    }
    U3TXREG = *string;
9d002ae8:	acc56420 	sw	a1,25632(a2)
    ++string;
9d002aec:	24840001 	addiu	a0,a0,1
  message[num_bytes] = '\0';
}

// Write a character array using UART3
void NU32_WriteUART3(const char * string) {
  while (*string != '\0') {
9d002af0:	80850000 	lb	a1,0(a0)
9d002af4:	14a0fff8 	bnez	a1,9d002ad8 <NU32_WriteUART3+0x10>
9d002af8:	00000000 	nop
9d002afc:	03e00008 	jr	ra
9d002b00:	00000000 	nop

Disassembly of section .text.general_exception:

9d002b04 <_general_exception_context>:
9d002b04:	27bdffa8 	addiu	sp,sp,-88
9d002b08:	afa10004 	sw	at,4(sp)
9d002b0c:	afa20008 	sw	v0,8(sp)
9d002b10:	afa3000c 	sw	v1,12(sp)
9d002b14:	afa40010 	sw	a0,16(sp)
9d002b18:	afa50014 	sw	a1,20(sp)
9d002b1c:	afa60018 	sw	a2,24(sp)
9d002b20:	afa7001c 	sw	a3,28(sp)
9d002b24:	afa80020 	sw	t0,32(sp)
9d002b28:	afa90024 	sw	t1,36(sp)
9d002b2c:	afaa0028 	sw	t2,40(sp)
9d002b30:	afab002c 	sw	t3,44(sp)
9d002b34:	afac0030 	sw	t4,48(sp)
9d002b38:	afad0034 	sw	t5,52(sp)
9d002b3c:	afae0038 	sw	t6,56(sp)
9d002b40:	afaf003c 	sw	t7,60(sp)
9d002b44:	afb80040 	sw	t8,64(sp)
9d002b48:	afb90044 	sw	t9,68(sp)
9d002b4c:	afbf0048 	sw	ra,72(sp)
9d002b50:	00004012 	mflo	t0
9d002b54:	afa8004c 	sw	t0,76(sp)
9d002b58:	00004010 	mfhi	t0
9d002b5c:	afa80050 	sw	t0,80(sp)
9d002b60:	3c1a9d00 	lui	k0,0x9d00
9d002b64:	275a2d24 	addiu	k0,k0,11556
9d002b68:	00000000 	nop
9d002b6c:	40046800 	mfc0	a0,c0_cause
9d002b70:	40056000 	mfc0	a1,c0_status
9d002b74:	0340f809 	jalr	k0
9d002b78:	00000000 	nop
9d002b7c:	8fa80050 	lw	t0,80(sp)
9d002b80:	01000011 	mthi	t0
9d002b84:	8fa8004c 	lw	t0,76(sp)
9d002b88:	01000013 	mtlo	t0
9d002b8c:	8fa10004 	lw	at,4(sp)
9d002b90:	8fa20008 	lw	v0,8(sp)
9d002b94:	8fa3000c 	lw	v1,12(sp)
9d002b98:	8fa40010 	lw	a0,16(sp)
9d002b9c:	8fa50014 	lw	a1,20(sp)
9d002ba0:	8fa60018 	lw	a2,24(sp)
9d002ba4:	8fa7001c 	lw	a3,28(sp)
9d002ba8:	8fa80020 	lw	t0,32(sp)
9d002bac:	8fa90024 	lw	t1,36(sp)
9d002bb0:	8faa0028 	lw	t2,40(sp)
9d002bb4:	8fab002c 	lw	t3,44(sp)
9d002bb8:	8fac0030 	lw	t4,48(sp)
9d002bbc:	8fad0034 	lw	t5,52(sp)
9d002bc0:	8fae0038 	lw	t6,56(sp)
9d002bc4:	8faf003c 	lw	t7,60(sp)
9d002bc8:	8fb80040 	lw	t8,64(sp)
9d002bcc:	8fb90044 	lw	t9,68(sp)
9d002bd0:	8fbf0048 	lw	ra,72(sp)
9d002bd4:	27bd0058 	addiu	sp,sp,88
9d002bd8:	000000c0 	ehb
9d002bdc:	42000018 	eret

Disassembly of section .text:

9d002be0 <memset>:
9d002be0:	00801021 	move	v0,a0
9d002be4:	10c00026 	beqz	a2,9d002c80 <memset+0xa0>
9d002be8:	2cca0010 	sltiu	t2,a2,16
9d002bec:	1540001f 	bnez	t2,9d002c6c <memset+0x8c>
9d002bf0:	30a500ff 	andi	a1,a1,0xff
9d002bf4:	00055200 	sll	t2,a1,0x8
9d002bf8:	00aa2825 	or	a1,a1,t2
9d002bfc:	00055400 	sll	t2,a1,0x10
9d002c00:	00aa2825 	or	a1,a1,t2
9d002c04:	30830003 	andi	v1,a0,0x3
9d002c08:	10600005 	beqz	v1,9d002c20 <memset+0x40>
9d002c0c:	24070004 	li	a3,4
9d002c10:	00e33823 	subu	a3,a3,v1
9d002c14:	00c73023 	subu	a2,a2,a3
9d002c18:	b8850000 	swr	a1,0(a0)
9d002c1c:	00872021 	addu	a0,a0,a3
9d002c20:	30c3000f 	andi	v1,a2,0xf
9d002c24:	00c33823 	subu	a3,a2,v1
9d002c28:	10e00008 	beqz	a3,9d002c4c <memset+0x6c>
9d002c2c:	00603021 	move	a2,v1
9d002c30:	00e43821 	addu	a3,a3,a0
9d002c34:	ac850000 	sw	a1,0(a0)
9d002c38:	ac850004 	sw	a1,4(a0)
9d002c3c:	ac850008 	sw	a1,8(a0)
9d002c40:	24840010 	addiu	a0,a0,16
9d002c44:	1487fffb 	bne	a0,a3,9d002c34 <memset+0x54>
9d002c48:	ac85fffc 	sw	a1,-4(a0)
9d002c4c:	30c30003 	andi	v1,a2,0x3
9d002c50:	00c33823 	subu	a3,a2,v1
9d002c54:	10e00005 	beqz	a3,9d002c6c <memset+0x8c>
9d002c58:	00603021 	move	a2,v1
9d002c5c:	00e43821 	addu	a3,a3,a0
9d002c60:	24840004 	addiu	a0,a0,4
9d002c64:	1487fffe 	bne	a0,a3,9d002c60 <memset+0x80>
9d002c68:	ac85fffc 	sw	a1,-4(a0)
9d002c6c:	10c00004 	beqz	a2,9d002c80 <memset+0xa0>
9d002c70:	00c43821 	addu	a3,a2,a0
9d002c74:	24840001 	addiu	a0,a0,1
9d002c78:	1487fffe 	bne	a0,a3,9d002c74 <memset+0x94>
9d002c7c:	a085ffff 	sb	a1,-1(a0)
9d002c80:	03e00008 	jr	ra
9d002c84:	00000000 	nop

Disassembly of section .text.main_entry:

9d002c88 <_main_entry>:
9d002c88:	3c040000 	lui	a0,0x0
9d002c8c:	27bdffe8 	addiu	sp,sp,-24
9d002c90:	24840000 	addiu	a0,a0,0
9d002c94:	10800003 	beqz	a0,9d002ca4 <_main_entry+0x1c>
9d002c98:	afbf0014 	sw	ra,20(sp)
9d002c9c:	0080f809 	jalr	a0
9d002ca0:	00000000 	nop
9d002ca4:	30840000 	andi	a0,a0,0x0
9d002ca8:	30a50000 	andi	a1,a1,0x0
9d002cac:	3c089d00 	lui	t0,0x9d00
9d002cb0:	25081e00 	addiu	t0,t0,7680
9d002cb4:	0100f809 	jalr	t0
9d002cb8:	00000000 	nop

9d002cbc <__crt0_exit>:
9d002cbc:	3c020000 24420000 10400003 00000000     ...<..B$..@.....
9d002ccc:	0040f809 00000000 1000fff9 00000000     ..@.............

Disassembly of section .text._bootstrap_exception_handler:

9d002cdc <_bootstrap_exception_handler>:
9d002cdc:	3c020000 	lui	v0,0x0
9d002ce0:	24420000 	addiu	v0,v0,0
9d002ce4:	10400005 	beqz	v0,9d002cfc <_bootstrap_exception_handler+0x20>
9d002ce8:	3c020000 	lui	v0,0x0
9d002cec:	24420000 	addiu	v0,v0,0
9d002cf0:	10400003 	beqz	v0,9d002d00 <_bootstrap_exception_handler+0x24>
9d002cf4:	3c029d00 	lui	v0,0x9d00
9d002cf8:	7000003f 	sdbbp
9d002cfc:	3c029d00 	lui	v0,0x9d00
9d002d00:	24422db4 	addiu	v0,v0,11700
9d002d04:	10400005 	beqz	v0,9d002d1c <.LCFI2>
9d002d08:	00000000 	nop
9d002d0c:	27bdffe8 	addiu	sp,sp,-24

9d002d10 <.LCFI0>:
9d002d10:	afbf0014 	sw	ra,20(sp)
9d002d14:	0040f809 	jalr	v0
9d002d18:	00000000 	nop

9d002d1c <.LCFI2>:
9d002d1c:	0b400b47 	j	9d002d1c <.LCFI2>
9d002d20:	00000000 	nop

Disassembly of section .text._general_exception_handler:

9d002d24 <_general_exception_handler>:
9d002d24:	3c020000 	lui	v0,0x0
9d002d28:	24420000 	addiu	v0,v0,0
9d002d2c:	10400005 	beqz	v0,9d002d44 <_general_exception_handler+0x20>
9d002d30:	3c020000 	lui	v0,0x0
9d002d34:	24420000 	addiu	v0,v0,0
9d002d38:	10400003 	beqz	v0,9d002d48 <_general_exception_handler+0x24>
9d002d3c:	3c029d00 	lui	v0,0x9d00
9d002d40:	7000003f 	sdbbp
9d002d44:	3c029d00 	lui	v0,0x9d00
9d002d48:	24422db4 	addiu	v0,v0,11700
9d002d4c:	10400005 	beqz	v0,9d002d64 <.LCFI2>
9d002d50:	00000000 	nop
9d002d54:	27bdffe8 	addiu	sp,sp,-24

9d002d58 <.LCFI0>:
9d002d58:	afbf0014 	sw	ra,20(sp)
9d002d5c:	0040f809 	jalr	v0
9d002d60:	00000000 	nop

9d002d64 <.LCFI2>:
9d002d64:	0b400b59 	j	9d002d64 <.LCFI2>
9d002d68:	00000000 	nop

Disassembly of section .vector_default:

9d002d6c <_DefaultInterrupt>:
9d002d6c:	3c020000 	lui	v0,0x0
9d002d70:	24420000 	addiu	v0,v0,0
9d002d74:	10400007 	beqz	v0,9d002d94 <_DefaultInterrupt+0x28>
9d002d78:	3c020000 	lui	v0,0x0
9d002d7c:	24420000 	addiu	v0,v0,0
9d002d80:	50400005 	beqzl	v0,9d002d98 <_DefaultInterrupt+0x2c>
9d002d84:	3c029d00 	lui	v0,0x9d00
9d002d88:	7000003f 	sdbbp
9d002d8c:	03e00008 	jr	ra
9d002d90:	00000000 	nop
9d002d94:	3c029d00 	lui	v0,0x9d00
9d002d98:	24422db4 	addiu	v0,v0,11700
9d002d9c:	10400003 	beqz	v0,9d002dac <_DefaultInterrupt+0x40>
9d002da0:	00000000 	nop
9d002da4:	0040f809 	jalr	v0
9d002da8:	00000000 	nop
9d002dac:	03e00008 	jr	ra
9d002db0:	00000000 	nop

Disassembly of section .text:

9d002db4 <__pic32_software_reset>:
9d002db4:	41606000 	di
9d002db8:	000000c0 	ehb
9d002dbc:	3c03aa99 	lui	v1,0xaa99
9d002dc0:	3c02bf81 	lui	v0,0xbf81
9d002dc4:	24636655 	addiu	v1,v1,26197
9d002dc8:	ac40f230 	sw	zero,-3536(v0)
9d002dcc:	ac43f230 	sw	v1,-3536(v0)
9d002dd0:	3c035566 	lui	v1,0x5566
9d002dd4:	346399aa 	ori	v1,v1,0x99aa
9d002dd8:	ac43f230 	sw	v1,-3536(v0)
9d002ddc:	3c02bf81 	lui	v0,0xbf81
9d002de0:	24030001 	li	v1,1
9d002de4:	ac43f618 	sw	v1,-2536(v0)
9d002de8:	3c02bf81 	lui	v0,0xbf81
9d002dec:	8c42f610 	lw	v0,-2544(v0)
9d002df0:	0b400b6f 	j	9d002dbc <__pic32_software_reset+0x8>
9d002df4:	00000000 	nop

Disassembly of section .dinit:

9d002df8 <.dinit>:
9d002df8:	a0000020 	sb	zero,32(zero)
9d002dfc:	00000404 	0x404
9d002e00:	00000000 	nop
9d002e04:	a0000000 	sb	zero,0(zero)
9d002e08:	00000020 	add	zero,zero,zero
	...
9d002e14:	22222222 	addi	v0,s1,8738

Disassembly of section .text:

9d002e18 <_nmi_handler>:
9d002e18:	401a6000 	mfc0	k0,c0_status
9d002e1c:	3c1bffbf 	lui	k1,0xffbf
9d002e20:	377bffff 	ori	k1,k1,0xffff
9d002e24:	035bd024 	and	k0,k0,k1
9d002e28:	409a6000 	mtc0	k0,c0_status
9d002e2c:	42000018 	eret

Disassembly of section .text._on_reset:

9d002e30 <_on_reset>:
9d002e30:	03e00008 	jr	ra
9d002e34:	00000000 	nop

Disassembly of section .text._on_bootstrap:

9d002e38 <_on_bootstrap>:
9d002e38:	03e00008 	jr	ra
9d002e3c:	00000000 	nop
